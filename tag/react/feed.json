{
    "version": "https://jsonfeed.org/version/1",
    "title": "THEO • All posts by \"react\" tag",
    "description": "",
    "home_page_url": "https://zztqsh.github.io",
    "items": [
        {
            "id": "https://zztqsh.github.io/2021/05/19/react%E7%AC%94%E8%AE%B0/",
            "url": "https://zztqsh.github.io/2021/05/19/react%E7%AC%94%E8%AE%B0/",
            "title": "react笔记",
            "date_published": "2021-05-18T16:00:00.000Z",
            "content_html": "<h1 id=\"day01\"><a href=\"#day01\" class=\"headerlink\" title=\"day01\"></a>day01</h1><h2 id=\"1-项目开发准备\"><a href=\"#1-项目开发准备\" class=\"headerlink\" title=\"1. 项目开发准备\"></a>1. 项目开发准备</h2><pre><code>1). 描述项目\n2). 技术选型 \n3). API接口/接口文档/测试接口\n</code></pre>\n<h2 id=\"2-启动项目开发\"><a href=\"#2-启动项目开发\" class=\"headerlink\" title=\"2. 启动项目开发\"></a>2. 启动项目开发</h2><pre><code>1). 使用react脚手架创建项目\n2). 开发环境运行: npm start\n3). 生产环境打包运行: npm run build   serve build\n</code></pre>\n<h2 id=\"3-git管理项目\"><a href=\"#3-git管理项目\" class=\"headerlink\" title=\"3. git管理项目\"></a>3. git管理项目</h2><pre><code>1). 创建远程仓库\n2). 创建本地仓库\n    a. 配置.gitignore\n    b. git init\n    c. git add .\n    d. git commit -m &quot;init&quot;\n3). 将本地仓库推送到远程仓库\n    git remote add origin url\n    git push origin master\n4). 在本地创建dev分支, 并推送到远程\n    git checkout -b dev\n    git push origin dev\n5). 如果本地有修改\n    git add .\n    git commit -m &quot;xxx&quot;\n    git push origin dev\n6). 新的同事: 克隆仓库\n    git clone url\n    git checkout -b dev origin/dev\n    git pull origin dev\n7). 如果远程修改\n    git pull origin dev\n    \n</code></pre>\n<h2 id=\"4-创建项目的基本结构\"><a href=\"#4-创建项目的基本结构\" class=\"headerlink\" title=\"4. 创建项目的基本结构\"></a>4. 创建项目的基本结构</h2><pre><code>api: ajax请求的模块\ncomponents: 非路由组件\npages: 路由组件\nApp.js: 应用的根组件\nindex.js: 入口js    \n</code></pre>\n<h2 id=\"5-引入antd\"><a href=\"#5-引入antd\" class=\"headerlink\" title=\"5 引入antd\"></a>5 引入antd</h2><pre><code>下载antd的包\n按需打包: 只打包import引入组件的js/css\n    下载工具包\n    config-overrides.js\n    package.json\n自定义主题\n    下载工具包\n    config-overrides.js\n使用antd的组件\n    根据antd的文档编写\n    \n</code></pre>\n<h2 id=\"6-引入路由\"><a href=\"#6-引入路由\" class=\"headerlink\" title=\"6. 引入路由\"></a>6. 引入路由</h2><pre><code>下载包: react-router-dom\n拆分应用路由:\n  Login: 登陆\n  Admin: 后台管理界面\n注册路由:\n  &lt;BrowserRouter&gt;\n  &lt;Switch&gt;\n  &lt;Route path=&#39;&#39; component=&#123;&#125;/&gt;\n  \n</code></pre>\n<h2 id=\"7-Login的静态组件\"><a href=\"#7-Login的静态组件\" class=\"headerlink\" title=\"7. Login的静态组件\"></a>7. Login的静态组件</h2><pre><code>1). 自定义了一部分样式布局\n2). 使用antd的组件实现登陆表单界面\n  Form  / Form.Item\n  Input\n  Icon\n  Button\n</code></pre>\n<h2 id=\"8-收集表单数据和表单的前台验证\"><a href=\"#8-收集表单数据和表单的前台验证\" class=\"headerlink\" title=\"8. 收集表单数据和表单的前台验证\"></a>8. 收集表单数据和表单的前台验证</h2><pre><code>1). form对象\n    如何让包含&lt;Form&gt;的组件得到form对象?  WrapLoginForm = Form.create()(LoginForm)\n    WrapLoginForm是LoginForm的父组件, 它给LoginForm传入form属性\n    用到了高阶函数和高阶组件的技术\n2). 操作表单数据\n    form.getFieldDecorator(&#39;标识名称&#39;, &#123;initialValue: 初始值, rules: []&#125;)(&lt;Input/&gt;)包装表单项组件标签\n    form.getFieldsValue(): 得到包含所有输入数据的对象\n    form.getFieldValue(id): 根据标识得到对应字段输入的数据 \n3). 前台表单验证\n    a. 声明式实时表单验证:\n        form.getFieldDecorator(&#39;标识名称&#39;, &#123;rules: [&#123;min: 4, message: &#39;错误提示信息&#39;&#125;]&#125;)(&lt;Input/&gt;)\n    b. 自定义表单验证\n        form.getFieldDecorator(&#39;标识名称&#39;, &#123;rules: [&#123;validator: this.validatePwd&#125;]&#125;)(&lt;Input/&gt;)\n        validatePwd = (rule, value, callback) =&gt; &#123;\n          if(有问题) callback(&#39;错误提示信息&#39;) else callack()\n        &#125; \n    c. 点击提示时统一验证\n        form.validateFields((error, values) =&gt; &#123;\n          if(!error) &#123;通过了验证, 发送ajax请求&#125;\n        &#125;)\n        \n</code></pre>\n<h2 id=\"9-高阶函数与高阶组件\"><a href=\"#9-高阶函数与高阶组件\" class=\"headerlink\" title=\"9. 高阶函数与高阶组件\"></a>9. 高阶函数与高阶组件</h2><pre><code>1. 高阶函数\n    1). 一类特别的函数\n        a. 接受函数类型的参数\n        b. 返回值是函数\n    2). 常见\n        a. 定时器: setTimeout()/setInterval()\n        b. Promise: Promise(() =&gt; &#123;&#125;) then(value =&gt; &#123;&#125;, reason =&gt; &#123;&#125;)\n        c. 数组遍历相关的方法: forEach()/filter()/map()/reduce()/find()/findIndex()\n        d. 函数对象的bind()\n        e. Form.create()() / getFieldDecorator()()\n    3). 高阶函数更新动态, 更加具有扩展性   \n2. 高阶组件\n    1). 本质就是一个函数\n    2). 接收一个组件(被包装组件), 返回一个新的组件(包装组件), 包装组件会向被包装组件传入特定属性\n    3). 作用: 扩展组件的功能\n    \n3. 高阶组件与高阶函数的关系\n    高阶组件是特别的高阶函数\n    接收一个组件函数, 返回是一个新的组件函数\n    \n</code></pre>\n<h1 id=\"day02\"><a href=\"#day02\" class=\"headerlink\" title=\"day02\"></a>day02</h1><h2 id=\"1-后台应用\"><a href=\"#1-后台应用\" class=\"headerlink\" title=\"1. 后台应用\"></a>1. 后台应用</h2><pre><code>启动后台应用: mongodb服务必须启动\n使用postman测试接口(根据接口文档):\n    访问测试: post请求的参数在body中设置\n    保存测试接口\n    导出/导入所有测试接口\n    \n</code></pre>\n<h2 id=\"2-编写ajax代码\"><a href=\"#2-编写ajax代码\" class=\"headerlink\" title=\"2. 编写ajax代码\"></a>2. 编写ajax代码</h2><pre><code>1). ajax请求函数模块: api/ajax.js\n    封装axios + Promise\n    函数的返回值是promise对象  ===&gt; 后面用上async/await\n    自己创建Promise\n      1. 内部统一处理请求异常: 外部的调用都不用使用try..catch来处理请求异常\n      2. 异步返回是响应数据(而不是响应对象): 外部的调用异步得到的就直接是数据了(response --&gt; response.data)\n2). 接口请求函数模块: api/index.js\n    根据接口文档编写(一定要具备这个能力)\n    接口请求函数: 使用ajax(), 返回值promise对象\n3). 解决ajax跨域请求问题(开发时)\n    办法: 配置代理  ==&gt; 只能解决开发环境\n    编码: package.json: proxy: &quot;http://localhost:5000&quot;\n4). 对代理的理解\n    1). 是什么?\n        具有特定功能的程序\n    2). 运行在哪?\n        前台应用端\n        只能在开发时使用\n    3). 作用?\n        解决开发时的ajax请求跨域问题\n        a. 监视并拦截请求(3000)\n        b. 转发请求(4000)\n    4). 配置代理\n        告诉代理服务器一些信息: 比如转发的目标地址\n        开发环境: 前端工程师\n        生产环境: 后端工程师\n5). async和await\n    a. 作用?\n       简化promise对象的使用: 不用再使用then()来指定成功/失败的回调函数\n       以同步编码(没有回调函数了)方式实现异步流程\n    b. 哪里写await?\n        在返回promise的表达式左侧写await: 不想要promise, 想要promise异步执行的成功的value数据\n    c. 哪里写async?\n        await所在函数(最近的)定义的左侧写async\n        \n</code></pre>\n<h2 id=\"3-实现登陆-包含自动登陆\"><a href=\"#3-实现登陆-包含自动登陆\" class=\"headerlink\" title=\"3. 实现登陆(包含自动登陆)\"></a>3. 实现登陆(包含自动登陆)</h2><pre><code>login.jsx\n    1). 调用登陆的接口请求\n    2). 如果失败, 显示错误提示信息\n    3). 如果成功了:\n        保存user到local/内存中\n        跳转到admin\n    4). 如果内存中的user有值, 自动跳转到admin\nsrc/index.js\n    读取local中user到内存中保存\nadmin.jsx\n    判断如果内存中没有user(_id没有值), 自动跳转到login\nstorageUtils.js\n    包含使用localStorage来保存user相关操作的工具模块\n    使用第三库store\n        简化编码\n        兼容不同的浏览器\nmemoryUtils.js\n    用来在内存中保存数据(user)的工具类\n    \n</code></pre>\n<h2 id=\"4-搭建admin的整体界面结构\"><a href=\"#4-搭建admin的整体界面结构\" class=\"headerlink\" title=\"4. 搭建admin的整体界面结构\"></a>4. 搭建admin的整体界面结构</h2><pre><code>1). 整体布局使用antd的Layout组件\n2). 拆分组件\n    LeftNav: 左侧导航\n    Header: 右侧头部\n3). 子路由\n    定义路由组件\n    注册路由\n    \n</code></pre>\n<h2 id=\"5-LeftNav组件\"><a href=\"#5-LeftNav组件\" class=\"headerlink\" title=\"5. LeftNav组件\"></a>5. LeftNav组件</h2><pre><code>1). 使用antd的组件\n    Menu / Item / SubMenu\n\n2). 使用react-router\n    withRouter(): 包装非路由组件, 给其传入history/location/match属性\n    history: push()/replace()/goBack()\n    location: pathname属性\n    match: params属性  \n3). componentWillMount与componentDidMount的比较\n    componentWillMount: 在第一次render()前调用一次, 为第一次render()准备数据(同步)\n    componentDidMount: 在第一次render()之后调用一次, 启动异步任务, 后面异步更新状态重新render\n4). 根据动态生成Item和SubMenu的数组\n    map() + 递归: 多级菜单列表\n    reduce() + 递归: 多级菜单列表   \n5). 2个问题?\n    刷新时如何选中对应的菜单项?\n        selectedKey是当前请求的path\n    刷新子菜单路径时, 自动打开子菜单列表?\n        openKey是 一级列表项的某个子菜单项是当前对应的菜单项\n        \n</code></pre>\n<h1 id=\"day03\"><a href=\"#day03\" class=\"headerlink\" title=\"day03\"></a>day03</h1><h2 id=\"1-Header组件\"><a href=\"#1-Header组件\" class=\"headerlink\" title=\"1. Header组件\"></a>1. Header组件</h2><pre><code>1). 界面静态布局\n    三角形效果\n2). 获取登陆用户的名称显示\n    MemoryUtils\n3). 当前时间\n    循环定时器, 每隔1s更新当前时间状态\n    格式化指定时间: dateUtils\n4). 天气预报\n    使用jsonp库发jsonp请求百度天气预报接口\n    对jsonp请求的理解\n5). 当前导航项的标题\n    得到当前请求的路由path: withRouter()包装非路由组件\n    根据path在menuList中遍历查找对应的item的title\n6). 退出登陆\n    Modal组件显示提示\n    清除保存的user\n    跳转到login\n7). 抽取通用的类链接按钮组件\n    通过...透传所有接收的属性: &lt;Button &#123;...props&#125; /&gt;    &lt;LinkButton&gt;xxxx&lt;/LinkButton&gt;\n    组件标签的所有子节点都会成为组件的children属性\n    \n</code></pre>\n<h2 id=\"2-jsonp解决ajax跨域的原理\"><a href=\"#2-jsonp解决ajax跨域的原理\" class=\"headerlink\" title=\"2. jsonp解决ajax跨域的原理\"></a>2. jsonp解决ajax跨域的原理</h2><pre><code>1). jsonp只能解决GET类型的ajax请求跨域问题\n2). jsonp请求不是ajax请求, 而是一般的get请求\n3). 基本原理\n    浏览器端:\n        动态生成&lt;script&gt;来请求后台接口(src就是接口的url)\n        定义好用于接收响应数据的函数(fn), 并将函数名通过请求参数提交给后台(如: callback=fn)\n    服务器端:\n        接收到请求处理产生结果数据后, 返回一个函数调用的js代码, 并将结果数据作为实参传入函数调用\n    浏览器端:\n        收到响应自动执行函数调用的js代码, 也就执行了提前定义好的回调函数, 并得到了需要的结果数据\n       \n</code></pre>\n<h1 id=\"day04-Category组件\"><a href=\"#day04-Category组件\" class=\"headerlink\" title=\"day04: Category组件\"></a>day04: Category组件</h1><h2 id=\"1-使用antd组件构建分类列表界面\"><a href=\"#1-使用antd组件构建分类列表界面\" class=\"headerlink\" title=\"1. 使用antd组件构建分类列表界面\"></a>1. 使用antd组件构建分类列表界面</h2><pre><code>Card\nTable\nButton\nIcon\n    \n</code></pre>\n<h2 id=\"2-相关接口请求函数\"><a href=\"#2-相关接口请求函数\" class=\"headerlink\" title=\"2. 相关接口请求函数\"></a>2. 相关接口请求函数</h2><pre><code>获取一级/二级分类列表\n添加分类\n更新分类\n    \n</code></pre>\n<h2 id=\"3-异步显示一级分类列表\"><a href=\"#3-异步显示一级分类列表\" class=\"headerlink\" title=\"3. 异步显示一级分类列表\"></a>3. 异步显示一级分类列表</h2><pre><code>设计一级分类列表的状态: categorys\n异步获取一级分类列表: componentDidMount()&#123;&#125;\n更新状态, 显示\n</code></pre>\n<h2 id=\"4-显示二级分类列表\"><a href=\"#4-显示二级分类列表\" class=\"headerlink\" title=\"4. 显示二级分类列表\"></a>4. 显示二级分类列表</h2><pre><code>设计状态: subCategorys / parentId / parentName\n显示二级分类列表: 根据parentId状态值, 异步获取分类列表\nsetState()的问题\n    setState()更新状态是异步更新的, 直接读取状态值还是旧的状态值\n    setState(&#123;&#125;, [callback]), 回调函数是在状态更新且界面更新之后执行, 可以在此获取最新的状态\n    \n</code></pre>\n<h2 id=\"5-更新分类\"><a href=\"#5-更新分类\" class=\"headerlink\" title=\"5. 更新分类\"></a>5. 更新分类</h2><pre><code>1). 界面\n    antd组件: Modal, Form, Input\n    显示/隐藏: showStatus状态为2/0\n    \n2). 功能\n    父组(Category)件得到子组件(AddForm)的数据(form)\n    调用更新分类的接口\n    重新获取分类列表\n    \n    \n</code></pre>\n<h1 id=\"day05\"><a href=\"#day05\" class=\"headerlink\" title=\"day05\"></a>day05</h1><h2 id=\"1-添加分类\"><a href=\"#1-添加分类\" class=\"headerlink\" title=\"1. 添加分类\"></a>1. 添加分类</h2><pre><code>1). 界面\n    antd组件: Modal, Form, Select, Input\n    显示/隐藏: showStatus状态为1/0\n    \n2). 功能\n    父组(Category)件得到子组件(AddForm)的数据(form)\n    调用添加分类的接口\n    重新获取分类列表\n</code></pre>\n<h2 id=\"2-Product整体路由\"><a href=\"#2-Product整体路由\" class=\"headerlink\" title=\"2. Product整体路由\"></a>2. Product整体路由</h2><pre><code>1). 配置子路由: \n    ProductHome / ProductDetail / ProductAddUpdate\n    &lt;Route&gt; / &lt;Switch&gt; / &lt;Redirect&gt;\n\n2). 匹配路由的逻辑:\n    默认: 逐层匹配   &lt;Route path=&#39;/product&#39; component=&#123;ProductHome&#125;/&gt;\n    exact属性: 完全匹配\n    \n</code></pre>\n<h2 id=\"3-分页实现技术-2种\"><a href=\"#3-分页实现技术-2种\" class=\"headerlink\" title=\"3. 分页实现技术(2种)\"></a>3. 分页实现技术(2种)</h2><pre><code>1). 前台分页\n    请求获取数据: 一次获取所有数据, 翻页时不需要再发请求\n    请求接口: \n        不需要指定请求参数: 页码(pageNum)和每页数量(pageSize)\n        响应数据: 所有数据的数组   \n2). 基于后台的分页\n    请求获取数据: 每次只获取当前页的数据, 翻页时要发请求\n    请求接口: \n        需要指定请求参数: 页码(pageNum)和每页数量(pageSize)\n        响应数据: 当前页数据的数组 + 总记录数(total)   \n3). 如何选择?\n    基本根据数据多少来选择\n    \n</code></pre>\n<h2 id=\"4-ProductHome组件\"><a href=\"#4-ProductHome组件\" class=\"headerlink\" title=\"4. ProductHome组件\"></a>4. ProductHome组件</h2><pre><code>1). 分页显示\n   界面: &lt;Card&gt; / &lt;Table&gt; / Select / Icon / Input / Button\n   状态: products / total\n   接口请求函数需要的数据: pageNum, pageSize\n   异步获取第一页数据显示\n       调用分页的接口请求函数, 获取到当前页的products和总记录数total\n       更新状态: products / total\n   翻页:\n       绑定翻页的监听, 监听回调需要得到pageNum\n       异步获取指定页码的数据显示  \n \n2). 搜索分页\n   接口请求函数需要的数据: \n       pageSize: 每页的条目数\n       pageNum: 当前请求第几页 (从1开始)\n       productDesc / productName: searchName 根据商品描述/名称搜索\n   状态:  searchType / searchName  / 在用户操作时实时收集数据\n   异步搜索显示分页列表\n       如果searchName有值, 调用搜索的接口请求函数获取数据并更新状态\n       \n3). 更新商品的状态\n   初始显示: 根据product的status属性来显示  status = 1/2\n   点击切换:\n       绑定点击监听\n       异步请求更新状态  \n4). 进入详情界面\n   history.push(&#39;/product/detail&#39;, &#123;product&#125;)   \n5). 进入添加界面\n    history.push(&#39;/product/addupdate&#39;)\n    \n</code></pre>\n<h2 id=\"5-ProductDetail组件\"><a href=\"#5-ProductDetail组件\" class=\"headerlink\" title=\"5. ProductDetail组件\"></a>5. ProductDetail组件</h2><pre><code>1). 读取商品数据: this.props.location.state.product\n2). 显示商品信息: &lt;Card&gt; / List \n3). 异步显示商品所属分类的名称\n    pCategoryId==0 : 异步获取categoryId的分类名称\n    pCategoryId!=0: 异步获取 pCategoryId/categoryId的分类名称\n4). Promise.all([promise1, promise2])\n    返回值是promise\n    异步得到的是所有promsie的结果的数组\n    特点: 一次发多个请求, 只有当所有请求都成功, 才成功, 并得到成功的数据,一旦有一个失败, 整个都失败\n</code></pre>\n<h1 id=\"day06\"><a href=\"#day06\" class=\"headerlink\" title=\"day06\"></a>day06</h1><h2 id=\"1-ProductAddUpdate\"><a href=\"#1-ProductAddUpdate\" class=\"headerlink\" title=\"1. ProductAddUpdate\"></a>1. ProductAddUpdate</h2><pre><code>1). 基本界面\n    Card / Form / Input / TextArea / Button\n    FormItem的label标题和layout\n    \n2). 分类的级联列表\n    Cascader的基本使用\n    异步获取一级分类列表, 生成一级分类options\n    如果当前是更新二级分类的商品, 异步获取对应的二级分类列表, 生成二级分类options, 并添加为对应option的children\n    async函数返回值是一个新promise对象, promise的结果和值由async函数的结果决定\n    当选择某个一级分类项时, 异步获取对应的二级分类列表, 生成二级分类options, 并添加为当前option的children \n3). 表单数据收集与表单验证 \n</code></pre>\n<h2 id=\"2-PicturesWall\"><a href=\"#2-PicturesWall\" class=\"headerlink\" title=\"2. PicturesWall\"></a>2. PicturesWall</h2><pre><code>1). antd组件\n    Upload / Modal / Icon\n    根据示例DEMO改造编写\n2). 上传图片\n    在&lt;Upload&gt;上配置接口的path和请求参数名\n    监视文件状态的改变: 上传中 / 上传完成/ 删除\n    在上传成功时, 保存好相关信息: name / url\n    为父组件提供获取已上传图片文件名数组的方法\n3). 删除图片\n    当文件状态变为删除时, 调用删除图片的接口删除上传到后台的图片\n4). 父组件调用子组件对象的方法: 使用ref技术\n    1. 创建ref容器: thi.pw = React.createRef()\n    2. 将ref容器交给需要获取的标签元素: &lt;PicturesWall ref=&#123;this.pw&#125; /&gt;  // 自动将将标签对象添加为pw对象的current属性\n    3. 通过ref容器读取标签元素: this.pw.current\n</code></pre>\n<h1 id=\"day07\"><a href=\"#day07\" class=\"headerlink\" title=\"day07\"></a>day07</h1><h2 id=\"1-RichTextEditor\"><a href=\"#1-RichTextEditor\" class=\"headerlink\" title=\"1. RichTextEditor\"></a>1. RichTextEditor</h2><pre><code>1). 使用基于react的富文本编程器插件库: react-draft-wysiwyg\n2). 参考库的DEMO和API文档编写\n3). 如果还有不确定的, 百度搜索, 指定相对准确的关键字  \n</code></pre>\n<h2 id=\"2-完成商品添加与修改功能\"><a href=\"#2-完成商品添加与修改功能\" class=\"headerlink\" title=\"2. 完成商品添加与修改功能\"></a>2. 完成商品添加与修改功能</h2><pre><code>1). 收集输入数据\n    通过form收集: name/desc/price/pCategoryId/categoryId\n    通过ref收集: imgs/detail\n    如果是更新收集: _id\n    将收集数据封装成product对象\n2). 更新商品\n    定义添加和更新的接口请求函数\n    调用接口请求函数, 如果成功并返回商品列表界面\n</code></pre>\n<h2 id=\"3-角色管理\"><a href=\"#3-角色管理\" class=\"headerlink\" title=\"3. 角色管理\"></a>3. 角色管理</h2><pre><code>1). 角色前台分页显示\n2). 添加角色\n3). 给指定角色授权\n    界面: Tree\n    状态: checkedKeys, 根据传入的role的menus进行初始化\n    勾选某个Node时, 更新checkedKeys\n    点击OK时: 通过ref读取到子组件中的checkedKeys作为要更新product新的menus\n            发请求更新product\n    解决默认勾选不正常的bug: 利用组件的componentWillReceiveProps()\n</code></pre>\n<h1 id=\"day08\"><a href=\"#day08\" class=\"headerlink\" title=\"day08\"></a>day08</h1><h2 id=\"1-setState-的使用\"><a href=\"#1-setState-的使用\" class=\"headerlink\" title=\"1. setState()的使用\"></a>1. setState()的使用</h2><pre><code>1). setState(updater, [callback]),\n    updater为返回stateChange对象的函数: (state, props) =&gt; stateChange\n    接收的state和props被保证为最新的\n2). setState(stateChange, [callback])\n    stateChange为对象,\n    callback是可选的回调函数, 在状态更新且界面更新后才执行\n3). 总结:\n    对象方式是函数方式的简写方式\n        如果新状态不依赖于原状态 ===&gt; 使用对象方式\n        如果新状态依赖于原状态 ===&gt; 使用函数方式\n    如果需要在setState()后获取最新的状态数据, 在第二个callback函数中读取\n</code></pre>\n<h2 id=\"2-setState-的异步与同步\"><a href=\"#2-setState-的异步与同步\" class=\"headerlink\" title=\"2. setState()的异步与同步\"></a>2. setState()的异步与同步</h2><pre><code>1). setState()更新状态是异步还是同步的?\n    a. 执行setState()的位置?\n        在react控制的回调函数中: 生命周期勾子 / react事件监听回调\n        非react控制的异步回调函数中: 定时器回调 / 原生事件监听回调 / promise回调 /...\n    b. 异步 OR 同步?\n        react相关回调中: 异步\n        其它异步回调中: 同步 \n2). 关于异步的setState()\n    a. 多次调用, 如何处理?\n        setState(&#123;&#125;): 合并更新一次状态, 只调用一次render()更新界面 ---状态更新和界面更新都合并了\n        setState(fn): 更新多次状态, 但只调用一次render()更新界面  ---状态更新没有合并, 但界面更新合并了\n    b. 如何得到异步更新后的状态数据?\n        在setState()的callback回调函数中\n</code></pre>\n<h2 id=\"3-Component与PureComponent\"><a href=\"#3-Component与PureComponent\" class=\"headerlink\" title=\"3. Component与PureComponent\"></a>3. Component与PureComponent</h2><pre><code>1). Component存在的问题?\n    a. 父组件重新render(), 当前组件也会重新执行render(), 即使没有任何变化\n    b. 当前组件setState(), 重新执行render(), 即使state没有任何变化 \n2). 解决Component存在的问题\n    a. 原因: 组件的shouldcomponentUpdate()默认返回true, 即使数据没有变化render()都会重新执行\n    b. 办法1: 重写shouldComponentUpdate(), 判断如果数据有变化返回true, 否则返回false\n    c. 办法2: 使用PureComponent代替Component\n    d. 说明: 一般都使用PureComponent来优化组件性能\n3). PureComponent的基本原理\n    a. 重写实现shouldComponentUpdate()\n    b. 对组件的新/旧state和props中的数据进行浅比较, 如果都没有变化, 返回false, 否则返回true\n    c. 一旦componentShouldUpdate()返回false不再执行用于更新的render() \n4). 面试题:\n    组件的哪个生命周期勾子能实现组件优化?\n    PureComponent的原理?\n    区别Component与PureComponent?\n</code></pre>\n<h2 id=\"4-用户管理\"><a href=\"#4-用户管理\" class=\"headerlink\" title=\"4. 用户管理\"></a>4. 用户管理</h2><pre><code>1). 显示用户分页列表\n2). 添加用户\n3). 修改用户\n4). 删除用户\n</code></pre>\n<h2 id=\"5-导航菜单权限控制\"><a href=\"#5-导航菜单权限控制\" class=\"headerlink\" title=\"5. 导航菜单权限控制\"></a>5. 导航菜单权限控制</h2><pre><code>1). 基本思路(依赖于后台): \n    角色: 包含所拥有权限的所有菜单项key的数组: menus=[key1, key2, key3]\n    用户: 包含所属角色的ID: role_id\n    当前登陆用户: user中已经包含了所属role对象\n    遍历显示菜单项时: 判断只有当有对应的权限才显示\n2). 判断是否有权限的条件?\n    a. 如果当前用户是admin\n    b. 如果当前item是公开的\n    c. 当前用户有此item的权限: key有没有menus中\n    d. 如果当前用户有此item的某个子item的权限\n</code></pre>\n<h1 id=\"day09\"><a href=\"#day09\" class=\"headerlink\" title=\"day09\"></a>day09</h1><h2 id=\"1-redux理解\"><a href=\"#1-redux理解\" class=\"headerlink\" title=\"1. redux理解\"></a>1. redux理解</h2><pre><code>什么?: redux是专门做状态管理的独立第3方库, 不是react插件, 但一般都用在react项目中\n作用?: 对应用中状态进行集中式的管理(写/读)\n开发: 与react-redux, redux-thunk等插件配合使用\n</code></pre>\n<h2 id=\"2-redux相关API\"><a href=\"#2-redux相关API\" class=\"headerlink\" title=\"2. redux相关API\"></a>2. redux相关API</h2><pre><code>redux中包含: createStore(), applyMiddleware(), combineReducers()\nstore对象: getState(), dispatch(), subscribe()\nreact-redux: \n    &lt;Provider store=&#123;store&#125;&gt;: 向所有的容器组件提供store\n    connect(\n        state =&gt; (&#123;xxx: state.xxx&#125;),\n        &#123;actionCreator1, actionCreator2&#125;\n    )(UI组件): \n        产生的就是容器组件, 负责向UI组件传递标签属性, \n        一般属性值从state中获取, 函数属性内部会执行dispatch分发action\n</code></pre>\n<h2 id=\"3-redux核心概念-3个\"><a href=\"#3-redux核心概念-3个\" class=\"headerlink\" title=\"3. redux核心概念(3个)\"></a>3. redux核心概念(3个)</h2><pre><code>action: \n    默认是对象(同步action), &#123;type: &#39;xxx&#39;, data: value&#125;, 需要通过对应的actionCreator产生, \n    它的值也可以是函数(异步action), 需要引入redux-thunk才可以\nreducer\n    根据老的state和指定的action, 返回一个新的state\n    不能修改老的state\nstore\n    redux最核心的管理对象\n    内部管理着: state和reducer\n    提供方法: getState(), dispatch(action), subscribe(listener)\n</code></pre>\n<h2 id=\"4-redux工作流程\"><a href=\"#4-redux工作流程\" class=\"headerlink\" title=\"4. redux工作流程\"></a>4. redux工作流程</h2><p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg\" class=\"lazyload\" data-srcset=\"http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg\" srcset=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=\"></p>\n<h2 id=\"5-使用redux及相关库编码\"><a href=\"#5-使用redux及相关库编码\" class=\"headerlink\" title=\"5. 使用redux及相关库编码\"></a>5. 使用redux及相关库编码</h2><pre><code>需要引入的库: \n    redux\n    react-redux\n    redux-thunk\n    redux-devtools-extension(这个只在开发时需要)\nredux文件夹: \n    action-types.js\n    actions.js\n    reducers.js\n    store.js\n组件分2类: \n    ui组件(components): 不使用redux相关API\n    容器组件(containers): 通过connect()()生成的组件\n    \n</code></pre>\n<h1 id=\"day10\"><a href=\"#day10\" class=\"headerlink\" title=\"day10\"></a>day10</h1><h2 id=\"1-在项目中搭建redux整套环境\"><a href=\"#1-在项目中搭建redux整套环境\" class=\"headerlink\" title=\"1. 在项目中搭建redux整套环境\"></a>1. 在项目中搭建redux整套环境</h2><pre><code>1). store.js\n2). reducer.js\n3). actions.js\n4). action-types.js\n5). index.js\n6). 在需要与redux进行状态数据通信(读/写)的UI组件包装生成容器组件\n</code></pre>\n<h2 id=\"2-通过redux管理头部标题headTitle数据\"><a href=\"#2-通过redux管理头部标题headTitle数据\" class=\"headerlink\" title=\"2. 通过redux管理头部标题headTitle数据\"></a>2. 通过redux管理头部标题headTitle数据</h2><pre><code>1). action-types.js\n2). actoins.js\n3). reducer.js\n4). 相关组件: \n    left-nav.js\n    header.js\n    \n</code></pre>\n<h2 id=\"3-通过redux管理登陆用户信息user数据\"><a href=\"#3-通过redux管理登陆用户信息user数据\" class=\"headerlink\" title=\"3. 通过redux管理登陆用户信息user数据\"></a>3. 通过redux管理登陆用户信息user数据</h2><pre><code>1). action-types.js\n2). actoin.js\n3). reducer.js\n4). 相关组件: \n    login.js\n    admin.js\n    left-nav.js\n    header.js\n    role.js\n</code></pre>\n<h2 id=\"4-自定义redux库\"><a href=\"#4-自定义redux库\" class=\"headerlink\" title=\"4. 自定义redux库\"></a>4. 自定义redux库</h2><pre><code>1). redux库向外暴露下面几个函数\n    createStore(): 接收的参数为reducer函数, 返回为store对象\n    combineReducers(): 接收包含n个reducer方法的对象, 返回一个新的reducer函数\n    applyMiddleware() // 暂不实现\n2). store对象的内部结构\n    getState(): 返回值为内部保存的state数据\n    dispatch(): 参数为action对象\n    subscribe(): 参数为监听内部state更新的回调函数 \n3). combineReducers函数:\n    返回的总reducer函数内部会根据总的state和指定的action, \n    调用每个reducer函数得到对应的新的state, 并封装成一个新的总state对象返回\n</code></pre>\n<h2 id=\"5-自定义react-redux库\"><a href=\"#5-自定义react-redux库\" class=\"headerlink\" title=\"5. 自定义react-redux库\"></a>5. 自定义react-redux库</h2><pre><code>1). react-redux向外暴露了2个API\n    a. Provider组件类\n    b. connect函数  \n2). Provider组件\n    接收store属性\n    通过context将store暴露给所有的容器子组件\n    Provider原样渲染其所有标签子节点\n    \n3). connect函数\n    接收2个参数: mapStateToProps和mapDispatchToProps\n    connect()执行的返回值为一个高阶组件: 包装UI组件, 返回一个新的容器组件\n    mapStateToProps: \n        为一个函数, 返回包含n个一般属性对象, \n        容器组件中调用得到对象后, 初始化为容器组件的初始状态, 并指定为UI组件标签的一般属性\n    mapDispatchToProps:\n        如果为函数, 调用得到包含n个dispatch方法的对象\n        如果为对象, 遍历封装成包含n个dispatch方法的对象\n        将包含n个dispatch方法的对象分别作为函数属性传入UI组件\n    通过store绑定state变化的监听, 在回调函数中根据store中最新的state数据更新容器组件状态, 从而更新UI组件\n</code></pre>\n<h1 id=\"day11\"><a href=\"#day11\" class=\"headerlink\" title=\"day11\"></a>day11</h1><h2 id=\"1-数据可视化\"><a href=\"#1-数据可视化\" class=\"headerlink\" title=\"1. 数据可视化\"></a>1. 数据可视化</h2><pre><code>1). echarts(百度) ==&gt; echarts-for-react\n2). g2(阿里) ==&gt; bizCharts\n3). d3(国外)\n</code></pre>\n<h2 id=\"2-前台404界面\"><a href=\"#2-前台404界面\" class=\"headerlink\" title=\"2. 前台404界面\"></a>2. 前台404界面</h2><pre><code>&lt;Redirect from=&#39;/&#39; to=&#39;/home&#39; exact/&gt;\n&lt;Route component=&#123;NotFound&#125;/&gt;  \n</code></pre>\n<h2 id=\"3-打包应用运行\"><a href=\"#3-打包应用运行\" class=\"headerlink\" title=\"3. 打包应用运行\"></a>3. 打包应用运行</h2><pre><code>1). 解决生产环境ajax跨域问题\n    使用nginx的反向代理解决(一般由后台配置)\n    CORS: 允许浏览器端跨域\n2). BrowserRouter模式刷新404的问题\n    a. 问题: 刷新某个路由路径时, 会出现404的错误\n    b. 原因: 项目根路径后的path路径会被当作后台路由路径, 去请求对应的后台路由, 但没有\n    c. 解决: 使用自定义中间件去读取返回index页面展现\n</code></pre>\n",
            "tags": [
                "学习笔记",
                "react"
            ]
        }
    ]
}